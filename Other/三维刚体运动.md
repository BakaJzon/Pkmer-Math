---
tags:
  - 数学
  - SLAM
  - 机器人动力学
dlink:
---
- [[#1. 点、向量和坐标系]]
- [[#2.坐标系间的欧式变换]]
- - [[#2.1 旋转]]
    - [[#2.2 平移]]
- [[#3.齐次坐标和变换矩阵]]
- [[#4. 相似、仿射和射影变换]]
- - [[#4.1 相似变换]]
    - [[#4.2 仿射变换]]
    - [[#4.3 射影变换]]
    - [[#4.4 总结]]
- [[#5.实践: Eigen]]
序言: 本系列文章参考高翔老师的《视觉SLAM十四讲: 从理论到实践》, 详细讲解了三维空间中的刚体运动, 旨在为读者打下坚实的数学基础. 原书的第三讲被拆分为五个部分, 其中四元数的内容较为复杂, 因此被进一步细分为四个小节. 如果读者急于进入实践阶段, 可以直接阅读第五部分, 该部分详细介绍了机器人运动轨迹的演示和必要的安装步骤. 本系列的总目录如下: 
- 旋转矩阵和变换矩阵
- 旋转向量表示旋转
- 欧拉角表示旋转
- 四元数, 包括: 
  - 4-1. 四元数表示变换
  - 4-2. 四元数线性插值方法: LinEuler、LinMat、Lerp、Nlerp、Slerp
  - 4-3. 四元数多点插值方法: Squad
  - 4-4. 四元数多点连续解析解插值方法: Spicv
  - 4-5. 四元数多点离散数值解插值方法: Sping
- 实践: 展示SLAM中的机器人运动轨迹及相机位姿
在正式开始之前, 我想分享一下我的学习体会. 之前在学习SLAM时, 我曾在第六讲时因为理解不够深刻而放弃. 后来学习了一本关于强化学习的书籍后, 我才重新静下心来继续学习SLAM. 因此, 我建议研究SLAM的朋友们, 高翔博士的书虽然内容精炼, 但需要反复阅读, 特别是第三讲和第四讲, 我自己就反复阅读了四次. 学习SLAM的关键是复习旧知识以获得新知识, 深入理解并总结各个部分的内容, 将前后知识点串联起来, 这样才能理解后续的内容. 
本文首先介绍向量及其在坐标系中的表示, 并详细讲解了向量之间的运算. 接着, 我们利用欧式变换来描述坐标系之间的运动, 这种变换由旋转和平移两部分组成, 旋转部分由[[旋转矩阵]]$SO(3)$描述, 平移部分则由一个$\mathbb{R}^3$向量直接表示. 最后, 我们将讨论如何将旋转和平移组合成一个变换矩阵$SE(3)$. 本文还将在欧氏变换的基础上, 讲解相似、仿射和射影变换. 
# 1. 点、向量和坐标系
在本节中, 我们将讨论刚体、点、向量、坐标和坐标系, 以及内积和外积的基本概念, 这是为了引出外积的符号表示 $a \wedge$. 
- **刚体**: 是指其形状和大小不变的物体. 在我们生活的三维空间中, 一个空间点可以由三个坐标来确定其位置. 而刚体不仅有位置, 还有其自身的姿态, 即物体的朝向. 
- **点**: 空间中的基本元素, 无长度和体积. 两个点的连接形成一个向量. 
- **向量**: 可以视为从一点指向另一点的箭头, 它在空间中具有确定的方向和大小. 在不同坐标系中, 同一向量的坐标可能不同. 
- **坐标**: 在线性空间中, 选择一组基( 一组张成该空间的线性无关向量, 称为基底) , 如 $(e_1, e_2, e_3)$, 则任意向量 $a$ 在这组基下的坐标表示为: 
$$
a = [e_1, e_2, e_3] \begin{bmatrix} a_1 \\ a_2 \\ a_3 \end{bmatrix} = a_1 e_1 + a_2 e_2 + a_3 e_3
$$
  这里 $(a_1, a_2, a_3)^T$ 称为向量 $a$ 在此基下的坐标. 坐标的具体取值既与向量本身的属性有关, 也与所选取的坐标系( 基底) 有关. 本文中的向量均为列向量, 与一般数学书籍的表示方法相同. 
- **坐标系**: 通常由三个正交的坐标轴组成, 当给定 $x$ 轴和 $y$ 轴时, $z$ 轴可以通过右手法则( 或左手法则) 由 $x \times y$ 确定. 根据定义方法的不同, 坐标系又分为左手系和右手系. 在右手系中, 大拇指指向 $x$ 轴正方向, 食指指向 $y$ 轴正方向, 中指指向 $z$ 轴. 大部分3D程序库使用右手系( 如OpenGL、3D Max等) , 而部分库使用左手系( 如Unity、Direct3D等) . 
- **内积**: 向量的数乘、加减法在此不再赘述. 内积通常可以写为: 
$$
a \cdot b = a^T b = \sum_{i=1}^{3} a_i b_i = |a| |b| \cos \langle a, b \rangle
$$
  其中 $\langle a, b \rangle$ 表示向量 $a$ 和 $b$ 之间的夹角. 内积还可以描述向量间的投影关系. 
- **外积**: 外积定义如下: 
$$
a \times b = \begin{vmatrix} e_1 & e_2 & e_3 \\ a_1 & a_2 & a_3 \\ b_1 & b_2 & b_3 \end{vmatrix} = [a_2 b_3 - a_3 b_2, a_3 b_1 - a_1 b_3, a_1 b_2 - a_2 b_1] = [0, -a_3, a_2; a_3, 0, -a_1; -a_2, a_1, 0] b = \text{def} \, a \wedge b
$$
  外积的结果是一个向量, 其方向垂直于原来的两个向量, 大小等于两个向量构成的平行四边形的有向面
# 2. 坐标系间的欧式变换
本节是整本书中非常关键的部分, 请务必仔细理解和掌握. 首先, 我们从刚体运动的概念引出欧式变换. 
在实际应用中, 我们常常需要定义多种坐标系. 例如, 在考虑一个移动中的机器人( 或相机) 时, 常见的做法是设立一个惯性坐标系( 也称为世界坐标系) , 这个坐标系被认为是固定不变的. 在这种情况下, 我们可能会遇到这样一个问题: 如果在相机的视野中有一个向量 $p$, 在相机坐标系下的坐标表示为 $p_c$, 而在世界坐标系下的坐标表示为 $p_w$, 那么这两个坐标之间如何转换？
为了解答这一问题, 首先需要确定该点相对于机器人坐标系的坐标值, 然后根据机器人的位姿将其转换到世界坐标系中. 这种转换可以通过数学中的变换矩阵 $T$ 来描述. 
### 刚体运动
两个坐标系之间的运动转换由旋转和平移两部分组成, 这种运动被称为刚体运动. 相机的运动就是一个典型的刚体运动例子. 在刚体运动过程中, 任何一个向量在所有坐标系下的长度和与其他向量的夹角都保持不变. 因此, 我们可以说, 手机坐标系与世界坐标系之间的差异可以通过一个[[欧氏变换]]( Euclidean Transform) 来描述. 欧氏变换由旋转和平移组成, 它能够完整地描述从一个坐标系到另一个坐标系的过渡. 
这种变换的数学表示通常涉及到[[旋转矩阵]]和[[平移向量]]的组合, 表达为一个[[增广矩阵]], 能够同时处理旋转和平移, 从而在多种应用场景中提供一种统一的处理方式. 在接下来的部分, 我们将进一步探讨如何具体应用这些变换, 以及它们在不同场景下的具体表现和计算方法. 
## 2.1 旋转
在这一节中, 我们将探讨旋转及其数学表示——旋转矩阵和[[特殊正交群]] $SO(n)$. 
### 旋转矩阵
假设有一个单位正交[[基]] $e = (e_1, e_2, e_3)$, 通过旋转变换后变为 $e' = (e_1', e_2', e_3')$. 对于任何一个向量 $a$, 其在这两个坐标系中的坐标分别为 $[a_1, a_2, a_3]$ 和 $[a_1', a_2', a_3']$. 因为向量本身未变, 我们有: 
$$
[e_1, e_2, e_3] \begin{bmatrix} a_1 \\ a_2 \\ a_3 \end{bmatrix} = [e_1', e_2', e_3'] \begin{bmatrix} a_1' \\ a_2' \\ a_3' \end{bmatrix} \tag{2.1}
$$
为了描述两个坐标之间的关系, 对上式两边同时左乘 $e^T$( 原基的转置) , 则左侧变为单位矩阵, 从而有: 
$$
[a_1, a_2, a_3] = [e_1^T e_1', e_1^T e_2', e_1^T e_3', e_2^T e_1', e_2^T e_2', e_2^T e_3', e_3^T e_1', e_3^T e_2', e_3^T e_3'] \begin{bmatrix} a_1' \\ a_2' \\ a_3' \end{bmatrix} \equiv R [a_1', a_2', a_3'] \tag{2.2}
$$
其中矩阵 $R$ 由两组基的内积组成, 描述了旋转前后同一个向量的坐标变换关系, 因此称为旋转矩阵( Rotation Matrix) . 此矩阵也是方向余弦矩阵, 因为其元素是两组基向量间夹角的余弦值. 
旋转矩阵 $R$ 是一个正交矩阵, 它的逆( 即转置) 描述了相反的旋转. 具体表达为: 
$$
a' = R^{-1} a = R^T a \tag{2.3}
$$
这表明 $R^{-1}$ 和 $R^T$ 描述了一个相反的旋转. 
### 特殊正交群 $SO(n)$
旋转矩阵 $R$ 是具有单位行列式的正交矩阵( 即 $A^{-1} = A^T$) , 行列式为 1 的正交矩阵也是旋转矩阵. 因此, 可以定义 $n$-维旋转矩阵的集合如下: 
$$
SO(n) = \{ R \in \mathbb{R}^{n \times n} \mid RR^T = I, \text{det}(R) = 1 \} \tag{2.4}
$$
这里 $SO(n)$ 表示特殊正交群( Special Orthogonal Group) , 是 $n$-维空间中的旋转矩阵集合. 特别地, $SO(3)$ 表示三维空间中的旋转. 通过旋转矩阵, 我们可以直接讨论两个坐标系之间的旋转变换, 无需重新定义基向量. 
## 2.2 平移
在欧式变换的讨论中, 除了旋转, 平移也是一个重要的组成部分. 
在考虑如何描述三维空间中物体的运动时, 我们通常需要处理旋转和平移这两种基本变换. 考虑一个向量 $a$ 在世界坐标系中的位置, 通过一个旋转矩阵 $R$ 和一个平移向量 $t$ 对其进行变换后, 得到新的向量位置 $a'$. 这种变换可以用以下数学表达式来描述: 
$$
a' = Ra + t \tag{2.5}
$$
这个方程使用旋转矩阵 $R$ 和平移向量 $t$ 完整地描述了欧式空间中的坐标变换. 
### 坐标系间的变换关系
在实际应用中, 我们可能需要在不同的坐标系之间转换向量的坐标. 假设我们有两个坐标系: 坐标系1和坐标系2. 向量 $a$ 在这两个坐标系中的坐标分别表示为 $a_1$ 和 $a_2$. 这两个坐标之间的关系可以通过下面的公式表达: 
$$
a_1 = R_{12} a_2 + t_{12} \tag{2.6}
$$
这里的 $R_{12}$ 是一个旋转矩阵, 描述了如何将坐标系2中的向量 $a_2$ 旋转到坐标系1中. $t_{12}$ 是一个平移向量, 表示从坐标系1的原点到坐标系2原点的向量. 
#### 符号约定
在处理这些变换时, $R_{12}$ 的下标“12”表示这是一个从坐标系2到坐标系1的变换矩阵. 因为向量乘在矩阵的右侧, 所以下标从右到左读取, 表示从坐标系2变换到坐标系1. 关于平移向量 $t_{12}$, 它表示从坐标系1原点到坐标系2原点的向量, 下标从左读到右, 即从1到2. 这个平移向量不等于 $-t_{21}$, 其中 $t_{21}$ 是从坐标系2到坐标系1原点的向量. 
这些变换是理解和描述物体在三维空间中如何移动的基础, 对于机器人导航、计算机图形学以及其他需要精确空间认知的领域至关重要. 
# 3.齐次坐标和变换矩阵
在欧式变换中, 我们通常会遇到旋转和平移的组合, 这些组合可以形成复杂的空间变换. 这些变换的线性关系可以通过[[齐次]]坐标和变换矩阵来优雅地表达. 
### 齐次坐标
在处理变换时, 一个常见的数学技巧是使用齐次坐标. 我们可以将一个三维向量 $a$ 扩展为四维向量 $\tilde{a}$, 在向量的末尾添加一个1, 这样 $\tilde{a}$ 就表示为 $[a_1, a_2, a_3, 1]^T$. 这种表示法允许我们使用单一的矩阵来同时处理旋转和平移, 这在数学和编程中都是非常有用的. 
齐次坐标的使用使得向量的表示不再唯一, 因为除以一个非零常数 $h$ 后, $[h a_1, h a_2, h a_3, h]$ 仍然表示同一个点. 如果 $h = 0$, 则该点代表一个无穷远的点. 在数学和计算机图形学中, 这种表示法可以简化透视投影和其他变换的处理. 
### 变换矩阵
齐次坐标使我们能够将旋转和平移组合进一个单一的4x4矩阵 $T$ 中, 这使整个变换关系变成线性的: 
$$
\tilde{a}' = T \tilde{a} = \begin{bmatrix} R & t \\ 0 & 1 \end{bmatrix} \begin{bmatrix} a \\ 1 \end{bmatrix} = \begin{bmatrix} Ra + t \\ 1 \end{bmatrix}
$$
其中 $R$ 是一个旋转矩阵, $t$ 是一个平移向量. 这种表示不仅简洁而且强大, 因为它可以通过矩阵乘法来组合多个变换. 
### 叠加变换
当需要应用多个变换时, 例如首先应用变换 $T_1$, 然后应用 $T_2$, 变换的组合可以直接通过矩阵乘法实现: 
$$
\tilde{c} = T_2 T_1 \tilde{a}
$$
这种方式极大地简化了连续变换的处理, 并且保持了数学上的严谨性和计算上的效率. 
### 特殊欧式群 SE(3)
变换矩阵 $T$ 的结构非常特殊, 它属于[[特殊欧式群]]$SE(3)$, 这是包含了所有旋转和平移的变换矩阵的集合. 特殊欧式群的定义为: 
$$
SE(3) = \left\{ T_E = \begin{bmatrix} R & t \\ 0 & 1 \end{bmatrix} \in \mathbb{R}^{4 \times 4} \mid R \in SO(3), t \in \mathbb{R}^3 \right\}
$$
这个群描述了三维空间中所有可能的刚体变换, 包括旋转和平移. 
通过这些数学工具, 我们可以高效并准确地描述和计算在机器人技术、计算机视觉、航天和许多其他领域中遇到的空间变换问题. 
# 4. 相似、仿射和射影变换
除了欧式变换, 3D空间还存在其他几种变换方式, 只不过欧氏变换是最简单的. 它们一部分和测量几何有关, 因为在之后的讲解中可能会提到, 所以先罗列出来. 欧氏变换保持了向量的长度和夹角, 相当于我们把一个刚体原封不动地进行了移动或旋转, 不改变它自身的样子. 但现实中由于角度问题, 总会发生畸变, 所以需要相似、仿射、射影变换, 它们都会改变物体的外形. 它们都有类似的矩阵表示. 
## 4.1 相似变换
相似变换比欧式变换多了一个自由度, 它允许物体进行均匀缩放, 其矩阵表示为:
$$
T_S = \begin{bmatrix} sR & t \\ 0 & 1 \end{bmatrix} \tag{4.1}
$$
注意, 旋转部分多了一个缩放因子 $s$, 它表示我们在对向量旋转之后, 可以在 $x, y, z$ 三个坐标上进行均匀缩放. 由于含有缩放, 相似变换不再保持图形的面积不变. 你可以想象一个边长为1的立方体经过相似变换后, 变成边长为10的立方体. 三维相似变换的集合也叫做相似变换群, 记作 $Sim(3)$. 
## 4.2 仿射变换
仿射变换的矩阵形式如下:
$$
T_A = \begin{bmatrix} A & t \\ 0 & 1 \end{bmatrix} \tag{4.2}
$$
与欧式变换不同, 仿射变换只要求 $A$ 是一个可逆矩阵, 而不必是正交矩阵. 仿射变换也叫正交投影, 经过仿射变换之后, 立方体就不再是方的了, 但是各个方面仍然是平行四边形. 
## 4.3 射影变换
射影变换是最一般的变换, 又称为投影变换. 它的矩阵形式为:
$$
T_P = \begin{bmatrix} A & t \\ a^T & v \end{bmatrix} \tag{4.3}
$$
它的左上角为可逆矩阵 $A$, 右上角为平移 $t$, 左下角为缩放 $a^T$, 右下角为整体的变换比例 $v$. 由于采用了齐次坐标, 当 $v \neq 0$ 时, 我们可以对整个矩阵除以 $v$ 得到一个右下角为1的矩阵; 否则当 $v = 0$ 时, 得到右下角为0的矩阵. 因此, 2D的射影变换一共有8个自由度, 3D则共有15个自由度. 
射影变换是讲过的变换中, 形式最一般的. 从真实世界到相机照片的变换可以看成一个射影变换. 读者可以想象一个原本方形的地板砖, 在照片中是什么样子？首先, 它不再是方形的, 由于近大远小的关系, 它甚至不是平行四边形, 而是一个不规则的四边形. 这也是位姿中常遇到的情况. 
## 4.4 总结
下面是对讲到的四种变换的性质的总结. 请注意, 在“不变性质”部分, 特性是层级性的, 即从上到下, 每一层都包含上一层的性质. 例如, 欧氏变换除了保持体积不变, 还保持长度、夹角、平行性和相交性. 
### 常见变换的性质比较
| 变换名称 | 矩阵形式                                                  | 自由度 | 不变性质       | 变换形态        |
| ---- | ----------------------------------------------------- | --- | ---------- | ----------- |
| 欧氏变换 | $TE = \begin{bmatrix} R & t \\ 0 & 1 \end{bmatrix}$   | 6   | 长度、夹角、体积   | 位置, 方向改变    |
| 相似变换 | $TS = \begin{bmatrix} sR & t \\ 0 & 1 \end{bmatrix}$  | 7   | 体积比        | 按比例缩放       |
| 仿射变换 | $TA = \begin{bmatrix} A & t \\ 0 & 1 \end{bmatrix}$   | 12  | 平行性、体积比    | 正交投影, 平行性不变 |
| 射影变换 | $TP = \begin{bmatrix} A & t \\ a^T & v \end{bmatrix}$ | 15  | 接触平面的相交和相切 | 大小、平行性均发生改变 |
### 说明
- **欧氏变换**: 这是最基本的刚体变换, 包含旋转和平移, 但不改变形状和大小. 
- **相似变换**: 扩展自欧氏变换, 添加了缩放因素, 改变大小但保持形状. 
- **仿射变换**: 更一般的线性变换, 允许变换保持平行线不变, 但可以改变长度和角度. 
- **射影变换**: 最一般的线性变换, 包括透视效果, 可以改变几乎所有的几何属性. 
从真实世界到相机照片的变换可以被视为射影变换. 如果相机的焦距为无穷远, 那么变换简化为仿射变换. 在深入了解相机模型之前, 理解这些变换的基本特征已经足够. 这些知识对于理解如何通过变换来描述空间中对象的位置和方向是非常有用的. 
# 5.实践: Eigen
本节讲解如何使用Eigen表示矩阵和向量, 随后引申至旋转矩阵与变换矩阵的运算. KDevelop工程形式的代码在附件中. 
Eigen:Eigen是一个C++开源线性代数库, 它提供了快速的有关矩阵的线性代数运算, 还包括解方程等功能. 许多上层的软件库也使用Eigen进行矩阵运算, 包括g2o、Sophus等. 与其他库相比, Eigen的特殊之处在于, 它是一个纯用头文件搭建起来的库, 这意味着你只能找到它的头文件, 而没有类似.so或.a的二进制文件. 在使用时, 只需引入头文件即可, 不需要链接库文件. 例程只是介绍了基本的矩阵运算, 你可以通过Eigen官网教程学习更多Eigen知识. 
如果没有安装Eigen, 请输入以下命令进行安装: 
```shell
sudo apt install libeigen3-dev
```
下面写一段代码来实际练习Eigen的使用( 已添加注释) : 
```cpp
#include<iostream>
#include<ctime>
#include<eigen3/Eigen/Core>
#include<eigen3/Eigen/Dense>
using namespace std;
using namespace Eigen;
#define MATRIX_SIZE 50
int main(int argc, char **argv){
    Matrix<float, 2, 3> matrix_23f;
    Vector3d v_3d;
    Matrix<float, 3, 1> matrix_31f;
    Matrix3d matrix_33d = Matrix3d::Zero();
    Matrix<double, Dynamic, Dynamic> matrix_dynamic;
    MatrixXd matrix_x;
    matrix_23f << 1, 2, 3, 4, 5, 6;
    cout << "matrix 2*3 from 1 to 6:\n" << matrix_23f << endl;
    for (int i = 0; i < 2; i++) {
        for (int j = 0; j < 3; j++) {
            cout << matrix_23f(i, j) << "\t";
        }
        cout << endl;
    }
    v_3d << 3, 2, 1;
    matrix_31f << 4, 5, 6;
    // Performing multiplication with explicit casting
    Matrix<double, 2, 1> result = matrix_23f.cast<double>() * v_3d;
    cout << "[1,2,3;4,5,6]*[3,2,1]=" << result.transpose() << endl;
    Matrix<float, 2, 1> result2 = matrix_23f * matrix_31f;
    cout << "[1,2,3;4,5,6]*[4,5,6]=" << result2.transpose() << endl;
    matrix_33d = Matrix3d::Random();
    cout << "random matrix: \n" << matrix_33d << endl;
    cout << "transpose: \n" << matrix_33d.transpose() << endl;
    cout << "sum: " << matrix_33d.sum() << endl;
    cout << "trace: " << matrix_33d.trace() << endl;
    cout << "times 10: \n" << 10 * matrix_33d << endl;
    cout << "inverse: \n" << matrix_33d.inverse() << endl;
    cout << "det: " << matrix_33d.determinant() << endl;
    // Solving equations
    Matrix<double, MATRIX_SIZE, MATRIX_SIZE> matrix_NN = MatrixXd::Random(MATRIX_SIZE, MATRIX_SIZE);
    matrix_NN = matrix_NN * matrix_NN.transpose();
    Matrix<double, MATRIX_SIZE, 1> v_N1d = MatrixXd::Random(MATRIX_SIZE, 1);
    clock_t time_stt = clock();
    Matrix<double, MATRIX_SIZE, 1> x = matrix_NN.inverse()*v_N1d;
    cout << "time of normal inverse is " << 1000*(clock()-time_stt)/(double)CLOCKS_PER_SEC << "ms" << endl;
    cout << "x = " << x.transpose() << endl;
    time_stt = clock();
    x = matrix_NN.colPivHouseholderQr().solve(v_N1d);
    cout << "time of Qr decomposition is " << 1000*(clock()-time_stt)/(double)CLOCKS_PER_SEC << "ms" << endl;
    cout << "x = " << x.transpose() << endl;
    time_stt = clock();
    x = matrix_NN.ldlt().solve(v_N1d);
    cout << "time of ldlt decomposition is " << 1000*(clock()-time_stt)/(double)CLOCKS_PER_SEC << "ms" << endl;
    cout << "x = " << x.transpose() << endl;
    time_stt = clock();
    x = matrix_NN.lu().solve(v_N1d);
    cout << "time of lu decomposition is " << 1000*(clock()-time_stt)/(double)CLOCKS_PER_SEC << "ms" << endl;
    cout << "x = " << x.transpose() << endl;
    return 0;
}
```
CMakeLists.txt文件内容如下: 
```cmake
cmake_minimum_required(VERSION 3.0)
project(rigidMotion)
add_executable(useEigen useEigen.cpp)
set(CMAKE_BUILD_TYPE "Debug")
```
编译好程序后, 运行它, 可以看到各矩阵运算结果如下: 
```cmd
matrix 2*3 from 1 to 6:
1 2 3
4 5 6
print matrix 2*3:
1	2	3	
4	5	6	
[1,2,3;4,5,6]*[3,2,1]=10 28
[1,2,3;4,5,6]*[4,5,6]=32 77
random matrix: 
 0.680375   0.59688 -0.329554
-0.211234  0.823295  0.536459
 0.566198 -0.604897 -0.444451
transpose: 
 0.680375 -0.211234  0.566198
  0.59688  0.823295 -0.604897
-0.329554  0.536459 -0.444451
sum: 1.61307
trace: 1.05922
times 10: 
 6.80375   5.9688 -3.29554
-2.11234  8.23295  5.36459
 5.66198 -6.04897 -4.44451
inverse: 
-0.198521   2.22739    2.8357
  1.00605 -0.555135  -1.41603
 -1.62213   3.59308   3.28973
det: 0.208598
Eigen values=
0.0242899
 0.992154
  1.80558
Eigen vectors=
-0.549013 -0.735943  0.396198
 0.253452 -0.598296 -0.760134
-0.796459  0.316906 -0.514998
time of normal inverse is 1.967ms
x = -55.7896 -298.793  130.113 -388.455 -159.312  160.654 -40.0416 -193.561  155.844  181.144  185.125 -62.7786  19.8333 -30.8772 -200.746  55.8385 -206.604  26.3559 -14.6789  122.719 -221.449   26.233  -318.95 -78.6931  50.1446  87.1986 -194.922  132.319  -171.78 -4.19736   11.876 -171.779  48.3047  84.1812 -104.958 -47.2103 -57.4502 -48.9477 -19.4237  28.9419  111.421  92.1237 -288.248 -23.3478  -275.22 -292.062  -92.698  5.96847 -93.6244  109.734
time of Qr decomposition is 2.409ms
x = -55.7896 -298.793  130.113 -388.455 -159.312  160.654 -40.0416 -193.561  155.844  181.144  185.125 -62.7786  19.8333 -30.8772 -200.746  55.8385 -206.604  26.3559 -14.6789  122.719 -221.449   26.233  -318.95 -78.6931  50.1446  87.1986 -194.922  132.319  -171.78 -4.19736   11.876 -171.779  48.3047  84.1812 -104.958 -47.2103 -57.4502 -48.9477 -19.4237  28.9419  111.421  92.1237 -288.248 -23.3478  -275.22 -292.062  -92.698  5.96847 -93.6244  109.734
time of ldlt decomposition is 0.667ms
x = -55.7896 -298.793  130.113 -388.455 -159.312  160.654 -40.0416 -193.561  155.844  181.144  185.125 -62.7786  19.8333 -30.8772 -200.746  55.8385 -206.604  26.3559 -14.6789  122.719 -221.449   26.233  -318.95 -78.6931  50.1446  87.1986 -194.922  132.319  -171.78 -4.19736   11.876 -171.779  48.3047  84.1812 -104.958 -47.2103 -57.4502 -48.9477 -19.4237  28.9419  111.421  92.1237 -288.248 -23.3478  -275.22 -292.062  -92.698  5.96847 -93.6244  109.734
time of lu decomposition is 0.787ms
x = -55.7896 -298.793  130.113 -388.455 -159.312  160.654 -40.0416 -193.561  155.844  181.144  185.125 -62.7786  19.8333 -30.8772 -200.746  55.8385 -206.604  26.3559 -14.6789  122.719 -221.449   26.233  -318.95 -78.6931  50.1446  87.1986 -194.922  132.319  -171.78 -4.19736   11.876 -171.779  48.3047  84.1812 -104.958 -47.2103 -57.4502 -48.9477 -19.4237  28.9419  111.421  92.1237 -288.248 -23.3478  -275.22 -292.062  -92.698  5.96847 -93.6244  109.734
```
附件包含了第三讲所有代码. 
后续会介绍刚体运动第二部分: 旋转向量和欧拉角, 以及第三部分: 四元数表示旋转. 请继续学习, 欢迎留言讨论, 你的关注是我更新下去的动力. 
本文基于《视觉SLAM十四讲: 从理论到实践》和《Quaternions, Interpolation and Animation》编写, 但相对于原文会适当精简, 同时为便于全面理解, 会收集其他网络好文, 根据作者理解, 加入一些注解和扩展知识点, 如果您觉得还不错, 请一键四连( 点赞关注收藏评论) , 让更多的人看到. 
